# 依專案 Repo 保存的專案級 Obsidian 資料庫管理：Submodule 與 Monorepo 兩種型態的設計研究

## 執行摘要

你提出的改動核心是「**依專案保存、依附在專案 repo 底下**」，並且要支援兩種工程拓樸：  
其一是「主 repo（superproject）以 Git submodule 指向多個子 repo（submodules），索引資料庫放在主 repo」；其二是「單一主 repo（monorepo）內含所有微服務與 gateway」。兩種型態都能達成混合檢索（BM25/FTS5 + sqlite-vec）與自動化索引更新，但它們在**索引範圍邊界、權限治理、更新成本、以及 Obsidian vault 結構**上有本質差異。Git 官方文件指出 submodule 是「嵌入另一個 repo 的 repo」，superproject 會透過 gitlink 與 `.gitmodules` 記錄 submodule path/url，且 gitlink 指向 superproject 期待 submodule 工作目錄所在的 commit。citeturn7view0turn7view1turn7view2

基於你「單機可執行、盡量不用 MCP」「希望 Claude 執行結束後自動更新、避免人為管理」「允許自動修改筆記」「session 保存到 vault」的偏好，本報告建議把「自動化觸發」落在 **Claude Code 的 project skills + hooks**：  
- Claude Code 支援 **project scope skills**（可直接 commit 到 repo 的 `.claude/skills/<skill>/SKILL.md`），且在 monorepo 內還支援從子目錄自動發現巢狀 `.claude/skills/`，非常適合「每個服務一套規則」的治理方式。citeturn4view0  
- Claude Code hooks 可在其生命週期事件觸發（例如 `TaskCompleted`、`Stop`、`SessionEnd`），以「確定性」方式執行 shell 命令，不依賴模型自行決定是否要跑更新，並可把 hook 設為 project scope（`.claude/settings.json` 可 commit）。citeturn4view1turn16view0turn5view3  

資料庫層面，SQLite 官方文件建議 WAL 以提高並行（讀者不阻擋寫者、寫者不阻擋讀者），但也明確指出 WAL 不適用於 network filesystem、仍需面對 `SQLITE_BUSY` 並設 busy timeout 或 busy handler。citeturn12view3turn1search2turn1search15  
檢索層面，SQLite FTS5 的 `bm25()` 具備欄位權重、`rank` 欄位可更快排序；sqlite-vec 的 `vec0` 支援 KNN 查詢並回傳 distance。citeturn12view0turn12view2  

最後，在 Obsidian 結構上，你需要特別避免「vault within vault」：Obsidian 官方 help 明確建議不要在 vault 裡再放一個 vault，否則 internal links 可能無法正確更新。citeturn19view1turn19view3  
這對「主 repo + submodules」尤其關鍵：若每個 submodule 自己也有 `.obsidian`，就會形成 nested vault 風險；因此需要明確規範「只在主 repo（或指定 vault 根）放 `.obsidian`」，submodule 內不視為獨立 vault（或獨立 vault 就不要被主 vault 包進去）。

本報告的「來源優先順序」採：  
第一優先官方/原始文件（Claude Code docs、SQLite 官方 docs、Git 官方 docs、Obsidian 官方 docs、sqlite-vec 官方 repo/docs），第二優先學術與工程綜述（monorepo 文獻回顧、Google 單一 repository 論文），最後才用第三方文章作補充視角。citeturn4view0turn16view0turn12view0turn7view0turn19view1turn12view1turn11view0turn8view0  

## Repo 化專案保存的兩種型態

### 兩種型態的定義與你指定的保存位置

在語義上，這兩種型態可視為「Project monorepo」與「Multi-repo with submodules（superproject）」兩個常見分支：  
- monorepo：單一 repo 內含多個專案/模組（文獻回顧將 monorepo 常見定義為「單一 repository 含多個 projects」）。citeturn8view0turn8view2  
- submodules：superproject 以子目錄方式嵌入其他 repo；superproject 透過 gitlink 記錄「期望的 submodule commit」，並由 `.gitmodules` 設定 path/url 等資訊。citeturn7view0turn7view1  

你指定的保存策略是「依專案保存並依附 repo」，且在型態一（submodules）中「索引 DB 放在主 repo」。這會直接影響索引的主鍵設計：對外要以 repo root 作邊界、對內要以 path namespace（例如 `submodule_path` 或 `service_root`）做隔離鍵，避免不同服務的同名檔案互相污染召回與寫回。

### 選型比較：索引邊界、規則治理與可操作成本

下表以「索引與自動化」視角比較兩型態（偏向你關心的：自動更新、可擴充、避免人為管理、可寫回）：

| 面向 | 主 repo + submodules（DB 在主 repo） | 單一主 repo（monorepo） |
|---|---|---|
| 版本控制邊界 | submodule 具獨立歷史與版本；superproject 固定到特定 commit（gitlink）。citeturn7view0turn7view2 | 單一 repo 內集中版本化；跨服務變更可做 atomic changes（Google 單一 repo 模式強調 unified versioning / atomic changes）。citeturn11view0turn8view0 |
| 索引邊界 | 最自然：以主 repo 為「單一索引域」，用 `submodule_path` 分區；需處理 submodule 未初始化/被 deinit 的情況。citeturn7view0 | 以 repo 為單一索引域；更容易以資料夾（services/gateway）做 partition key；可對子目錄做規則/skills 分治。citeturn4view0turn8view0 |
| 規則治理（skills / hooks） | 可在主 repo 放 project skill；若子 repo 也要各自規則，避免 nested vault/規則衝突要慎規劃。citeturn4view0turn19view1 | Claude Code 支援從子目錄自動發現 `.claude/skills/`，適合「每個微服務一套技能/規則」。citeturn4view0 |
| 效能與規模風險 | 若 submodules 多且各自巨大，主索引庫寫入壓力集中，但仍可分區與增量更新。SQLite WAL 可提升讀寫並行，但仍是單機單寫者思維。citeturn12view3turn1search15 | monorepo 常見挑戰是規模與工具成本（文獻稱「codebase complexity」「tooling investments」等）。但可用 sparse-checkout 限制工作樹以降低操作成本。citeturn8view0turn3search2 |
| 權限與可見性 | 多 repo 有利於自然權限分割；但你要求 DB 在主 repo，意味索引可能收攏所有子 repo 內容到同一 DB。citeturn7view0turn8view2 | monorepo 常見挑戰之一是權限與可見性難題（完整 codebase 對所有人可見的風險）。不過你明確表示不需機密限制。citeturn8view2turn11view0 |
| Obsidian vault 的組織風險 | 若把主 repo 當 vault，而子 repo 也各自帶 `.obsidian`，會形成「vault within vault」的官方不建議模式。citeturn19view1 | monorepo 通常只有一個 vault（放在 repo root 或指定 docs/vault），較少 nested vault 問題。citeturn19view1 |

**結論性的建議**：  
- 若你強調「每個子服務仍要獨立 repo 與獨立 release/CI」，且你已經採 submodules 管理依賴，那型態一是合理的；但你需要額外處理 submodule 初始化/同步，以及避免 nested vault。citeturn7view0turn19view1  
- 若你強調「跨服務變更、整體自動化、與每個目錄可獨立套規則」，型態二通常更省心；Claude Code 的巢狀 skills 自動發現對 monorepo 特別友善。citeturn4view0turn8view0  

## 單機自動化：任務完成即增量索引與會話落盤

### 為什麼建議以 Claude Code 的 project skills + hooks 作為「不用 MCP」的自動化骨架

你想要「Claude 執行結束後就自動更新，避免人為管理資料庫」，這需要一個能在 agent 生命週期尾端觸發更新的機制。Claude Code hooks 的定位正是：在特定生命週期事件執行 shell 命令，提供**確定性控制**，避免「靠模型記得跑更新」的不穩定。citeturn4view1turn5view3turn16view0  

你也希望「依專案保存、依附 repo」，而 Claude Code 支援 project scope 的技能與 hook 設定檔：  
- skills：`.claude/skills/<skill-name>/SKILL.md` 可作為「此 repo 專用」技能，並可 commit，適合團隊共享。citeturn4view0  
- hooks：`.claude/settings.json` 可作為 project scope hook 設定並可 commit。citeturn5view3turn16view0  

此外，Claude Code 本身亦支援「sessions stored per project directory」，且 `/resume` picker 會依同一 git repo（含 worktrees）顯示 sessions，表示它在概念上就已 repo 為中心管理對話。citeturn15view0turn3search3  
你要求「session 保存到 vault」則可在 hooks 觸發的腳本中把摘要寫到 repo 內的 Obsidian 資料夾（而不是只留在工具內部）。citeturn15view0turn19view1  

### 事件驅動流程：從 TaskCompleted 觸發到索引更新與 session 摘要

Claude Code hooks 事件列表包含 `TaskCompleted`（任務標記完成）、`Stop`（Claude 完成回應）、`SessionEnd`（session 終止）等。citeturn5view3turn16view0  
對你的需求，「每次 Claude 任務做完就更新」最貼近 `TaskCompleted`，而「無論是否標記完成，只要回應就更新」則更像 `Stop`；若你擔心更新成本太高，可採「Stop 僅記錄 dirty、TaskCompleted 才真正做增量索引」。

```mermaid
flowchart TD
  A[Claude Code 編輯/寫入檔案] --> B[PostToolUse: 記錄 dirty 檔案集合]
  B --> C[TaskCompleted: 觸發 index.update]
  C --> D[掃描 repo / submodules 變更清單]
  D --> E[解析 Markdown + 切 chunk]
  E --> F[FTS5 upsert (BM25)]
  E --> G[遠端 embedding + sqlite-vec upsert]
  F --> H[SQLite transaction commit (WAL)]
  G --> H
  H --> I[寫入 session 摘要到 vault/sessions]
  H --> J[更新 path-map / catalog]
```

### hooks 設定與安全注意事項（單機仍需防呆）

hooks 會以「你的系統使用者」權限執行 shell 命令；官方也明確列出安全最佳實務：輸入驗證與清理、避免 path traversal（`..`）、引用變數要加引號、用 `$CLAUDE_PROJECT_DIR` 取專案根等。citeturn16view0  

以下是一個「任務完成即增量索引」的最小化設計（概念示例）：

- `.claude/settings.json`（project scope，可 commit）
```json
{
  "hooks": {
    "TaskCompleted": [
      {
        "hooks": [
          {
            "type": "command",
            "command": "\"$CLAUDE_PROJECT_DIR\"/.claude/hooks/index-update.sh"
          }
        ]
      }
    ]
  }
}
```

- `.claude/hooks/index-update.sh`（核心：呼叫你的 indexer CLI）
```bash
#!/usr/bin/env bash
set -euo pipefail

PROJECT_DIR="${CLAUDE_PROJECT_DIR:?missing}"
cd "$PROJECT_DIR"

# 1) 確保 submodule（型態一）已初始化（可選：若你允許自動 init）
# 2) 執行增量索引
python3 tools/projecthub/indexer.py update --repo-root "$PROJECT_DIR" --mode incremental

# 3) 產生 session 摘要（寫入 Obsidian vault 內）
python3 tools/projecthub/session.py save --repo-root "$PROJECT_DIR"
```

如需降低等待時間，可把索引設為 async hook（`"async": true`），但要理解 async hook 不能阻擋行為，其輸出會在下一個 turn 才送回。citeturn16view0  

## 索引與混合檢索：以 SQLite FTS5 BM25 + sqlite-vec 實作專案級資料庫

### SQLite 檢索能力的「原始文件基礎」

- FTS5 的 `bm25()`：回傳數值越小越匹配，並支援欄位權重；而隱藏欄位 `rank` 預設等同 `bm25()` 且排序更快。citeturn12view0  
- FTS5 提供 `rebuild` 命令可在索引與內容表不一致時丟棄並重建索引；並說明 external content table 一致性需由應用負責，否則結果不可預期。citeturn18view1turn18view2  
- sqlite-vec 的 `vec0`：官方宣告它是 pre-v1（可能 breaking changes），支援在 `vec0` virtual table 存取向量並做 KNN 查詢回傳 distance；文件展示 `MATCH` 與 `k = 10`、以及 join 回主表的模式。citeturn12view1turn12view2  
- Python 端載入 sqlite-vec：官方建議以 `db.enable_load_extension(True)` + `sqlite_vec.load(db)` + 再關閉，且提到 SQLite 3.41+ 建議版本。citeturn17view3turn12view2  

### Repo 取向的 schema：支援「每個服務/子 repo」命名空間

為滿足「每個程式碼檔案一個 Markdown」以及「型態一 submodules / 型態二 monorepo」共用架構，建議 schema 必須能表達以下鍵：

- `repo_root_id`：此索引 DB 對應哪個 repo  
- `namespace`：子服務或子 repo 的邏輯區隔（monorepo：`services/auth`；submodules：`.gitmodules` 定義的 submodule path）citeturn7view1turn8view0  
- `source_kind`：`code_note` / `rule` / `integration_doc` / `dir_map` / `session`  
- `source_path`：Markdown 在 vault 的路徑  
- `ref_code_path`（可選）：對應到原始程式碼檔案 path（讓你能從 code file 反查其筆記）

在 submodules 模式，namespace 的來源可直接取 `.gitmodules` 的 `submodule.<name>.path`，因為 `.gitmodules` 的第一級角色就是提供 submodule name 與 path 的映射。citeturn7view1turn7view0  

### 混合檢索（70/30）在 repo 型態下的調整策略

你的權重目標（BM25 70% + 向量 30%）可維持為預設，但 repo 型態會影響「候選集形成方式」：

- **submodules 型態**：先以 namespace 做 hard filter（例如只查某個 service submodule），再做混合；避免不同子 repo 的大量相似詞（例如 README、common rule）互相稀釋。此建議是工程性推論，但其必要性來自 submodule 的本質：superproject 會收攏多個獨立歷史與 commit 狀態的 repo，若不設矩形邊界容易混淆。citeturn7view0turn7view2  
- **monorepo 型態**：可依目錄樹（services/gateway）做 namespace；此外 Claude Code 在 monorepo 可從巢狀 `.claude/skills/` 加載各服務規則，等於在「檢索前」就能注入 domain prompt 以降低誤召回。citeturn4view0turn8view0  

混合排序的「可落地」要點仍是：BM25 與 distance 尺度不同，需做 per-query normalization，再以 0.7/0.3 線性融合；FTS5 的 `bm25()`、`rank`、欄位權重可用於把「title / heading / property」提升到更高訊號來源。citeturn12view0turn19view2  

### 高頻更新下的 SQLite 行為：WAL、busy timeout 與 FTS5 合併成本

你希望的「高頻更新」更像「每個 Claude 任務結束後就更新」：  
- 這會造成大量小交易。SQLite WAL 通常能提供更好並行，且讀寫可並行，但官方也指出 WAL 有限制（例如不適用 network filesystem）。citeturn12view3  
- `SQLITE_BUSY` 必須成為一級公民：SQLite 官方說明 busy timeout 會在遇到 lock 時睡眠重試，直到超過指定毫秒後仍忙碌才回 `SQLITE_BUSY`。citeturn1search2turn1search5  
- FTS5 在大量更新時會產生多個 b-tree segments，靠 `automerge` / `crisismerge` 合併；`crisismerge` 可能導致單次寫入變很慢（因觸發立即合併）。因此在「任務尾端更新」的場景，應盡量採批次 upsert + 單 transaction，避免許多細碎交易分散觸發 merge。citeturn18view0  

## Obsidian vault 與 Markdown 規範：以 repo 為單位的檔案映射與可寫回治理

### 依 repo 附著的 vault 放置模式

Obsidian 官方定義 vault 就是一個資料夾（含子資料夾），筆記是 Markdown 純文字；你可以在 OS 允許的任何地方建立 vault。citeturn19view1turn19view0  

但官方同時警告「vault within vault」：因 internal links 僅在 vault 內有效，嵌套 vault 可能導致連結更新不正確。citeturn19view1turn19view3  
因此，在你的兩種 repo 型態下，建議如下：

- **submodules 型態**：主 repo 建立單一 vault 根（例如 `docs/vault/` 或 repo root），submodule 目錄不要成為獨立 vault（避免子 repo 內再有 `.obsidian` 被主 vault 包進去）；要做 per-service 分治，用資料夾與 properties 而不是多個 `.obsidian`。citeturn19view1turn19view2  
- **monorepo 型態**：可把 vault 放在 repo root（若你不介意 repo 內混雜檔案），或放在 `docs/vault/`（較乾淨）；若你需要每個 service 有不同規則，優先用 Claude Code 的巢狀 skills（不是巢狀 vault）。citeturn4view0turn19view1  

此外，Obsidian 會在 vault 根建立 `.obsidian` 設定資料夾；官方也建議若用 Git 管理 vault，可能要把頻繁變動的 workspace JSON 加入 `.gitignore`，避免噪音提交。citeturn19view1  

### 「每個程式碼檔案一個 Markdown」的建議映射

你描述的內容包含：程式碼檔案對應筆記、守則、服務串接說明、以及檔案目錄結構。對此，建議的最小映射集合如下（不依賴你是否採 submodule 或 monorepo）：

| Vault 路徑（範例） | 用途 | 典型來源 | 需要被索引的原因 | 更新節奏 |
|---|---|---|---|---|
| `vault/code-notes/<repo-relpath>.md` | 單一程式碼檔案的說明（行為、依賴、注意事項） | Claude 生成/維護 | 對「問某支 API/某段程式」的 RAG 召回核心 | 任務結束後批次更新 |
| `vault/rules/` | 守則、規範、範本 | 人/Claude | 作為檢索與寫回的 guardrail，並可作為 FTS 權重提升欄位 | 低～中 |
| `vault/integrations/` | 服務串接、gateway、契約 | 人/Claude | 自然語言問句通常依賴語義相似度，向量檢索貢獻高 | 中 |
| `vault/structure/dir-map.md` | 目錄結構映射與命名空間說明 | 自動生成 | 可做「path→namespace→擁有者」 | 任務結束後更新（但可只改增量） |
| `vault/sessions/` | 對話摘要、決策、變更紀錄（你指定要放 vault） | 自動生成 | 讓日後檢索能找回「為什麼這樣改」 | 每次 TaskCompleted |

properties（結構化欄位）建議用於：`namespace`、`source_kind`、`ref_code_path`、`last_indexed`、`owner`、`status` 等。Obsidian 官方說 properties 是筆記的結構化資料（文字、日期、checkbox 等），並可與各種 search 語法搭配。citeturn19view2  

### 可寫回策略：避免連結與搬移造成系統性破壞

因你允許自動修改筆記，需要特別注意 Obsidian internal link 的穩定性：  
- Obsidian 支援 wikilink 與 Markdown link，且可在 rename 時自動更新 internal links。citeturn19view3  
- 但若你在 submodules 模式下對大量檔案做搬移/rename，再加上 nested vault 風險，容易引發 link 更新失準，因此需要明確規範「自動 rename/搬移」只能在單一 vault 域內進行，且要先生成目錄映射再行動。citeturn19view1turn19view3  

## 效能、可靠性與運維：增量索引在兩種 repo 型態的落地方式

### 增量索引：以「任務結束」為批次單位，而非每次檔案變動即寫 DB

你把高頻更新定義為「Claude 執行結束後自動執行」，這其實是很好的節奏，因為它天然形成「批次」：一次任務可能修改 N 個檔案，索引只需在尾端做一次交易。這能降低 FTS5 segments 合併壓力（automerge/crisismerge）並減少 busy/lock 風險。citeturn18view0turn1search2  

在兩種 repo 型態的差異實作：

- **submodules 型態（DB 在主 repo）**  
  1) 變更偵測：追蹤主 repo 與 submodule 目錄下的 Markdown（與必要的 code-notes）；  
  2) namespace：用 `.gitmodules` 的 submodule path 作為 namespace；  
  3) 若 submodule 可能未初始化或被 deinit，索引器應先檢查目錄是否存在工作樹，再決定是否跳過該 namespace。Git 官方說明 deinitialized submodule 可能沒有工作目錄，只留 gitlink 與 `.gitmodules` 設定。citeturn7view0turn7view1  

- **monorepo 型態**  
  1) namespace：用目錄（例如 `services/<name>`、`gateway/`）或由 `dir-map.md` 映射；  
  2) 治理：把 service-specific 的 skill 放在 `services/<svc>/.claude/skills/...`，Claude Code 會在你編輯該子目錄時自動發現該 skill，達成「同 repo 內分治」。citeturn4view0turn8view0  
  3) 若 repo 超大，可用 Git sparse-checkout 在本機只取部分工作樹，降低索引的 I/O 與掃描成本（Git 官方文件明確指出 sparse checkout 可把工作樹從全量改為子集合）。citeturn3search2  

### SQLite 運行參數：WAL、busy_timeout、以及 extension loading 安全

- WAL：SQLite 官方列出 WAL 的優點包含「讀者不阻擋寫者、寫者不阻擋讀者」；同時列出限制如「所有 process 必須在同一 host，WAL 不適用 network filesystem」。這與你「單機」目標吻合。citeturn12view3  
- busy_timeout：用於在鎖衝突時等待重試，直到累積睡眠時間超過門檻才回 `SQLITE_BUSY`。citeturn1search2turn1search15  
- sqlite-vec extension loading：SQLite 官方指出 extension loading 預設關閉是安全考量；並建議用 `SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION` 方式啟用 C-API 並保持 SQL `load_extension()` 關閉，以降低 SQL injection 風險。citeturn17view0turn17view1  
- sqlite-vec Python 端載入流程如前述（enable→load→disable），且文件提醒部分功能建議 SQLite 3.41+。citeturn17view3turn12view2  

### 測試與驗收指標：以「repo」為測量單位

你前一輪需求的驗收面向（準確率、召回率、延遲、資源）在此仍有效，但應按 repo 型態補充兩類測試：

- **拓樸測試**  
  - submodules：新增/刪除/deinit submodule 時，namespace 是否能正確出現在 path-map，且索引器不會因缺工作目錄而崩潰。citeturn7view0turn7view1  
  - monorepo：巢狀 skills 是否被正確發現（例如在 `packages/frontend/` 編輯時應發現該目錄下 `.claude/skills/`）。citeturn4view0  

- **自動化測試（hooks）**  
  - `TaskCompleted` 是否必定觸發 index.update（確定性）；  
  - hook 的 scope 是否為 project（可 commit）而非只在使用者機器上；  
  - hook 安全守則（引用變數、路徑檢查）符合官方安全建議。citeturn5view3turn16view0  

檢索品質指標（以 chunk 為單位的 Recall@K、MRR、nDCG）與延遲指標（p95 lexical、p95 vector、p95 merge）可沿用，但需把樣本查詢集分成：  
- 「精確詞/檔名/路徑」類（BM25 應佔優勢）  
- 「行為描述/串接流程」類（向量應提升召回）  
FTS5 的 `bm25()`、欄位權重與 `rank` 提供了可驗證的相關性排序基礎。citeturn12view0  

## 待確認項目

你已回答多數關鍵澄清，剩下這些是「落地時一定要定」的選項，會影響 repo 內的具體檔案位置與 hooks 腳本邏輯：

1) **Obsidian vault 在 repo 的位置**：你要把「整個 repo root」當 vault，還是固定用 `docs/vault/` 當 vault 根？（若用 repo root，`.obsidian` 會在 repo 根生成；若 submodules 內也有 `.obsidian`，需避免 nested vault，因官方不建議 vault within vault。）
只有root會有 vault

2) **型態一 submodules 的初始化策略**：索引更新時是否允許自動 `init/deinit`（或至少提示）？因 Git 文件指出 deinitialized submodule 可能沒有工作目錄。
提示



